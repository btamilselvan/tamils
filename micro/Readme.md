Discovery service:
	Keeps tracks of all available services, does load balancing.
	@EnableEurekaServer
	When using config server, make sure to use bootstrap.yml instead of default applicaiton.properties (it didn't work with app.properties)
	Set enableSelfPreservation to false to evict the clients if no heartbeat for configured (30 seconds default) interval.
	
	Discovery clients can use the below properties to register themselves with different names (when there are more than one instance of the same application).
	e.g.
	eureka.client.instance.instance-id=${spring.application.name}:${spring.application.instance_id:${random.value}}
	

Gateway service:
	All requests go thru gateway and gateway with the help of discovery distributes the load to the available services. (round-robin). 
	Make sure *not* to extend SpringBootServletInitializer and make sure spring-web dependency is not there in pom.xml.
	
Person and address services:
	Are the actual services and register with discovery service. Use ${PORT:0} to assign dynamic port
	
Config service:
	To maintain the configuration in one place.
	The config files should be in git repo for prod deployments. But for development this can be stored in the local file storage. But if local file storage is used then 
	the native profile has to be activated.
	Security:
		1. can be enabled by including spring-boot-starter-security dependency. This will enable basic authentication. The default user name will be user and password will be printed in the console during config server startup.
		2. To have custom credentials, include the username and password in properties file.
			spring.security.user.name=guest
			spring.security.user.password=can0n1947
	The parameters stored in the properties file can be encrypted using spring config encrypt/decrypt end-points.
	These end-points are enabled by defaults and supports both symmetric and asymmetric encryption. To enable symmetric encryptions just set the below property. 
	Make sure to disable csrf for /encrypt and /decrypt end-points.
	Encrypted values are prefixed with the string {cipher} and can be generated by an REST-call to the path /encrypt', if the server is configured to use a symmetric key or a key pair.
	The properties will be automatically decrypted when queried by config clients.
	
	encrypt.key=S0meK$y*7b12
	
	The config clients should set the username/password to connect to config server using the below properties:
	spring.cloud.config.username
	spring.cloud.config.passsword
  
	
	>ssh can also be used as long as the ssh keys are setup in the default directory ~/.ssh
	The below properties can be used to supply username password to clone remote repo
	spring.cloud.config.server.git.username=tamil
	spring.cloud.config.server.git.password=tamil

	> The config clients can refresh the properties using actuator/refresh end-point available. Add actuator support in the config client (pom). And enable actuator end-points using,
		management.endpoints.web.exposureinclude=refresh
	  Then send post request to refresh the properties. http://localhost:8232/actuator/refresh
	  The beans that annotated with @RefreshScope will be refreshed the new values from config server.
	> The refresh can be achieved using service bus as well. In this case, add message broker on both config client and server, and enable monitor on server (spring-cloud-config-monitor)
	  and config cloud bus settings in the server.
	> On the config client side, enable borker (spring-cloud-starter-bus-kafka), and add broker settings.
	> Now, refresh can be called from client using, http://localhost:8232/actuator/bus-refresh or from config server using,
	  http://localhost:8888/monitor
	  
	
Communication b/w services:
	Use Feign clients. Make sure to enable Feign clients in the application class.
	
Proxy service: 
	To load balance. make sure to add an entry to fetch service registry from eureka (fetchRegistry: true)

1. Two ways to refresh configuration changes in the config client services.
	1. using /refresh endpoint provided by spring boot actuator. a manual process.
	2. with /bus/refresh with spring-cloud-bus and in this case all the instances subscribe to an event and whenever this event is triggered, all the config properties will be automatically refreshed via spring cloud bus broadcasting.
		Setup a queue (e.g. RabbitMQ and add the configuration properties in config-server and config-clients). Now, the clients will have another end point /bus/refresh.  Calling this endpoint will cause:
			1. get the latest configuration from the config server and update its configuration annotated by @RefreshScope
			2. send a message to AMQP exchange informing about refresh event
			3. all subscribed nodes will update their configuration as well 
		
Include maven build plugin and package code using mvn package command. (this will create an executable jar)
Start spring boot using java command. port can be dynamically changed using vm arguments.
<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<version>2.1.3.RELEASE</version>
				<executions>
					<execution>
						<goals>
							<goal>repackage</goal>
						</goals>
					</execution>
				</executions>
			</plugin>

mvn package

If you do not include the <execution/> configuration, as shown in the prior example, you can run the plugin on its own (but only if the package goal is used as well), as shown in the following example:
mvn package spring-boot:repackage

java -jar -Dserver.port=80823 abc.jar

Docker notes:
Using localhost to lookup config and eureka servers doesn't work. have to use container-id in the url. for e.g  

Links:
https://dzone.com/articles/buiding-microservice-using-springboot-and-docker


1. connect containers using container-name (using links)
2. Also, network needs to be included and all services should be linked to the same n/w to allow inter communications
3. config and eurkea server needs to be up before other services are available. can be achieved using custom sh script.

