### Discovery service

- Keeps tracks of all available services, does load balancing.
- @EnableEurekaServer
- When using config server, make sure to use bootstrap.yml instead of default applicaiton.properties (it didn't work with app.properties)
- Set enableSelfPreservation to false to evict the clients if no heartbeat for configured (30 seconds default) interval.
- Discovery clients can use the below properties to register themselves with different name (when there are more than one instance of the same application)

```sh 
eureka.client.instance.instance-id=${spring.application.name}:${spring.application.instance_id:${random.value}}
```
- Eureka server can be secured using basic auth. Add security dependency and configure httpsecurity and secure the end-points. Make sure to disable csrf for /eureka end-points.
- The clients should include the user name and password in the defaultZone. e.g.

```sh 
defaultZone: http://apple:Go0gl3@localhost:8761/eureka/
```

- The eureka clients can use the below attributes to set the status page and health check indicators with eureka server.

```sh 
eureka:
  instance:
   statusPageUrlPath: ${management.endpoints.web.base-path}/info
   healthCheckUrlPath: ${management.endpoints.web.base-path}/health 
```

### Gateway service
- All requests go thru gateway and gateway with the help of discovery distributes the load to the available services. (round-robin).
- Make sure *not* to extend SpringBootServletInitializer and make sure spring-web dependency is not there in pom.xml. --??
- Use rewrite path to forward the request parameters, path variables to the target service.
- Use GlobalFilters to intercept requests. The filters can be chained in GlobalFilter to handle pre and post functionalities. See GatewaySecurity.java
- Spring gateway provides lot of in-built filters to achieve various functions. for e.g. RewritePath filter to rewrite the URL
	
### Person and address services
- Are the actual services and register with discovery service. Use ${PORT:0} to assign dynamic port
	
### Config service
- To maintain the configuration in one place.
- The config files should be in git repo for prod deployments. But for development this can be stored in the local file storage. But if local file storage is used then 
- The native profile has to be activated.

##### Security
- can be enabled by including spring-boot-starter-security dependency. This will enable basic authentication. The default user name will be user and password will be printed in the console during config server startup.
- To have custom credentials, include the username and password in properties file. e.g. below

```sh
spring.security.user.name=guest
spring.security.user.password=can0n1947
```

- The parameters stored in the properties file can be encrypted using spring config encrypt/decrypt end-points. These end-points are enabled by defaults and supports both symmetric and asymmetric encryption. To enable symmetric encryptions just set the below property.

```sh
encrypt.key=S0meK$y*7b12
```

- Make sure to disable csrf for config /encrypt and /decrypt end-points.
- Encrypted values are prefixed with the string {cipher} and can be generated by an REST-call to the path /encrypt', if the server is configured to use a symmetric key or a key pair. 
- The properties will be automatically decrypted when queried by config clients.
- The config clients should set the username/password to connect to config server using the below properties:

```sh
spring.cloud.config.username
spring.cloud.config.passsword
```
	
- ssh can also be used as long as the ssh keys are setup in the default directory ~/.ssh
- The below properties can be used to supply username password to clone remote repo

```sh
spring.cloud.config.server.git.username=tamil
spring.cloud.config.server.git.password=tamil
```
- The config clients can refresh the properties using actuator/refresh end-point available. Add actuator support in the config client (pom). And enable actuator end-points using,

```sh
management.endpoints.web.exposureinclude=refresh
```
- Send post request to refresh the properties. http://localhost:8232/actuator/refresh
- The beans that annotated with @RefreshScope will be refreshed the new values from config server.
- The refresh can be achieved using service bus as well. In this case, add message broker on both config client and server, and enable monitor on server (spring-cloud-config-monitor) and config cloud bus settings in the server.
- On the config client side, enable borker (spring-cloud-starter-bus-kafka), and add broker settings.
- Now, refresh can be called from client using, http://localhost:8232/actuator/bus-refresh or from config server using, http://localhost:8888/monitor
	  
### Communication b/w services	

- Use Feign clients. Make sure to enable Feign clients in the application class.
	
### Proxy service 
- To load balance. make sure to add an entry to fetch service registry from eureka (fetchRegistry: true)
- Two ways to refresh configuration changes in the config client services.
    1. using /refresh endpoint provided by spring boot actuator. a manual process.
    2. with /bus/refresh with spring-cloud-bus and in this case all the instances subscribe to an event and whenever this event is triggered, all the config properties will be automatically refreshed via spring cloud bus broadcasting.
- Setup a queue (e.g. RabbitMQ and add the configuration properties in config-server and config-clients). Now, the clients will have another end point /bus/refresh.  Calling this endpoint will cause:
    1. get the latest configuration from the config server and update its configuration annotated by @RefreshScope
    2. send a message to AMQP exchange informing about refresh event
    3. all subscribed nodes will update their configuration as well 

### Notes		
Include maven build plugin and package code using mvn package command. (this will create an executable jar)
Start spring boot using java command. port can be dynamically changed using vm arguments.
<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<version>2.1.3.RELEASE</version>
				<executions>
					<execution>
						<goals>
							<goal>repackage</goal>
						</goals>
					</execution>
				</executions>
			</plugin>

mvn package

If you do not include the <execution/> configuration, as shown in the prior example, you can run the plugin on its own (but only if the package goal is used as well), as shown in the following example:
mvn package spring-boot:repackage

java -jar -Dserver.port=80823 abc.jar

### Docker notes
Using localhost to lookup config and eureka servers doesn't work. have to use container-id in the url. for e.g  

Links:
https://dzone.com/articles/buiding-microservice-using-springboot-and-docker


1. connect containers using container-name (using links)
2. Also, network needs to be included and all services should be linked to the same n/w to allow inter communications
3. config and eurkea server needs to be up before other services are available. can be achieved using custom sh script.

#### Actuator
- when enabled, several end-points are available under /actuator. The below example will expose all end-points (but shutdown) and change the default "/actuator" context path to /manage. The /info end-point will use the information specified under "info" attribute.
- Specific end-points can be enabled instead of all end-points.
- The actuator end-points can be secured using SecurityFilterChain bean.
- Custom health information can provided by implementing HealthIndicator and by implementing Health() method.
- Custom actualtor end-points (in addition to default ones) can be added and exposed. If we add a @Bean annotated with @Endpoint, any methods annotated with @ReadOperation, @WriteOperation, or @DeleteOperation are automatically exposed over JMX and, in a web application, over HTTP as well.

```sh
management:
   endpoints:
      web:
         exposure:
            include: "*"
         base-path: /manage
      health:
      	  show-details: always
info:
	app:
		name: Address service
		description: A simple rest project using config, eureka and actuator features.
		version: 1.0
````
- The logger level can be changed runtime using /loggers end-point.
- Make sure to disable csrf for /loggers end-point as it is a post request. 
- Examples:

```sh
Existing logger level: http://localhost:60764/actuator/loggers
Existing logger level for a package: http://localhost:60764/manage/loggers/com.success.controllers
Change the logger level for a package: 
curl -i -X POST -H 'Content-Type: application/json' -d '{"configuredLevel": "DEBUG"}'
  http://localhost:8080/actuator/loggers/com.success.controllers
```
- When logback is used for logging, we can use the auto scan feature (scan="true) to reload the log level changes once in 'N" seconds. This is another way of changing the log level at run-time. 
- https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.loggers
- https://howtodoinjava.com/spring-boot/actuator-endpoints-example/
- restart endpoint can be enabled to restart the app. But restart code needs to be implemented using RestartEndPoint bean. Refer address-service.
- In order to have separate security mechanism/credentials for actuator and for the rest of the application, configure security for actuator end-points with highest precedence order, and another configuration for rest of the application with a filter. See AddressSecurity and AddressActuatorSecurity

### Spring Boot Admin
- We can let individual services register themselves with admin server or let the admin server fetch the services from eureka registry (if Eureka Service discovery is enabled). Using the latter approach is preferred because there is no need to include the admin dependencies in each service.
- When admin service uses eureka to fetch the clients, and if the clients have enabled security then the admin server should know the client credendtials to connect to the clients. To achieve that, we could let the clients (while registering with eureka) send eureka the meta data information. That meta data will include the user name and password needed to connect to themselves. The admin server will use that meta data to connect to the clients.

```sh
eureka:
   instance:
	   metadata-map:
   	   		user.name: address
   	   		user.password: Addres$3
   	   		management.context-path: ${management.endpoints.web.base-path}
```

- The clients can directly register themselves with the admin server using the below configuration (without Eureka)

```sh
spring.boot.admin.client.url=http://localhost:8080
```
- The actuator end-points have to be enabled in the client, in order for the server to query the client status.
- Security can be enabled on both client and server sides and the credential has to be shared with the server. Also, the client should know server's credentials to connect to. The client can refer the server's credentials using the below way,

```sh
spring.boot.admin.client.username=admin
spring.boot.admin.client.password=Password123
```
- The client should share its credential with server in the meta-data.

```sh
spring.security.user.name=client
spring.security.user.password=client
spring.boot.admin.client.instance.metadata.user.name=${spring.security.user.name}
spring.boot.admin.client.instance.metadata.user.password=${spring.security.user.password}
```

- A default security configuration has to be added on the admin server side for the client to connect. This is not needed when admin server uses the eureka is used to fetch the client. The above security mechanism is not needed when Eureka is used.


https://www.baeldung.com/spring-cloud-custom-gateway-filters
https://ihorkosandiak.medium.com/spring-cloud-gateway-security-with-jwt-93341b342020